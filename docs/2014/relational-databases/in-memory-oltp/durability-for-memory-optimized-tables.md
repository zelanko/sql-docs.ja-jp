---
title: メモリ最適化テーブルの持続性 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: d304c94d-3ab4-47b0-905d-3c8c2aba9db6
author: CarlRabeler
ms.author: carlrab
manager: craigg
ms.openlocfilehash: 3a35d5cdb9db4c56579a4229b2d08014a99da542
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/15/2019
ms.locfileid: "63072761"
---
# <a name="durability-for-memory-optimized-tables"></a>メモリ最適化テーブルの持続性
  [!INCLUDE[hek_2](../../../includes/hek-2-md.md)] により、メモリ最適化テーブルには完全な持続性が提供されます。 メモリ最適化テーブルを変更したトランザクションがコミットされると、基になるストレージが使用可能な場合、 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] では、(ディスク ベース テーブルの場合と同様に) この変更が永続的である (データベースの再起動後も保持される) ことが保証されます。 持続性には、トランザクション ログとディスク上ストレージでのデータ変更の保持という、2 つの主なコンポーネントがあります。  
  
## <a name="transaction-log"></a>トランザクション ログ  
 ディスク ベース テーブルまたは持続性のあるメモリ最適化テーブルに対するすべての変更は、1 つ以上のトランザクション ログ レコードにキャプチャされます。 トランザクションのコミット時に、 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] は、トランザクションに関連付けられているログ レコードをディスクに書き込んだ後、トランザクションによってコミットされたアプリケーションまたはユーザー セッションと通信します。 これにより、トランザクションによる変更が持続可能であることが保証されます。 メモリ最適化テーブルのトランザクション ログは、ディスク ベース テーブルで使用されている同じログ ストリームと完全に統合されています。 この統合によって、既存のトランザクション ログ バックアップ、復旧、および復元操作は引き続き機能し、追加の手順は必要ありません。 ただし、[!INCLUDE[hek_2](../../../includes/hek-2-md.md)] によりワークロードのトランザクションのスループットを大幅に向上できるため、トランザクション ログ ストレージが高くなった IO 要件を処理するよう正しく構成されていることを確認する必要があります。  
  
## <a name="data-and-delta-files"></a>データ ファイルとデルタ ファイル  
 メモリ最適化テーブルのデータは、1 つ以上のメモリ内インデックスでリンクされる自由形式のデータ行としてメモリに格納されます。 ディスク ベース テーブルで使用されるような、データ行のページ構造はありません。 アプリケーションがトランザクションをコミットできる状態になったら、[!INCLUDE[hek_2](../../../includes/hek-2-md.md)] によってトランザクションのログ レコードが生成されます。 メモリ最適化テーブルの永続化は、バックグラウンド スレッドを使用して一連のデータ ファイルおよびデルタ ファイルで実行されます。 データ ファイルとデルタ ファイルは 1 つ以上のコンテナーにあります (FILESTREAM データで使用される同様のメカニズムを使用しています)。 これらのコンテナーは、メモリ最適化ファイル グループと呼ばれる、新しい種類のファイル グループにマップされます。  
  
 データはこれらのファイルに厳密な順次形式で書き込まれるため、スピン メディアの場合のディスク待機時間が最小限に抑えられます。 異なるディスクにある複数のコンテナーを使用して、I/O 動作を分散することもできます。 異なるディスクにある複数のコンテナーにデータ ファイルとデルタ ファイルを配置すると、復旧時に、ディスク上のデータ ファイルとデルタ ファイルからメモリにデータが読み込まれるときのパフォーマンスが向上します。  
  
 アプリケーションは、直接データ ファイルとデルタ ファイルにアクセスしません。 すべてのデータ読み取りと書き込みには、インメモリ データが使用されます。  
  
### <a name="the-data-file"></a>データ ファイル  
 データ ファイルには、1 つ以上のメモリ最適化テーブルからの行が格納されます。これらの行は、INSERT 操作や UPDATE 操作の一部である複数のトランザクションによって挿入されたものです。 たとえば、ある行はメモリ最適化テーブル T1 から挿入され、次の行はメモリ最適化テーブル T2 から挿入されることがあります。 これらの行は、データ アクセスが順次的になるように、トランザクション ログ内のトランザクションの順序でデータ ファイルに追加されます。 これにより、ランダム I/O と比較した場合、I/O スループットが大幅に向上します。 各データ ファイルのサイズは、16 GB を超えるメモリを搭載するコンピューターでは約 128 MB、16 GB 以下のメモリを搭載するコンピューターでは約 16 MB になります。 データ ファイルがいっぱいになると、新しいトランザクションによって挿入される行は別のデータ ファイルに格納されます。 時間が経つにつれて、持続性のあるメモリ最適化テーブルの行を格納するデータ ファイルは増えていきます。データ ファイル間では、時間的に離れたトランザクションからの行が含まれることになりますが、1 つのデータ ファイル内のトランザクション範囲は連続しています。 たとえば、トランザクションのコミット タイムスタンプの範囲が (100, 200) であるデータ ファイルには、コミット タイムスタンプが 100 より大きく 200 以下のトランザクションによって挿入されたすべての行が含まれています。 コミット タイムスタンプとは、コミットの準備ができたトランザクションに割り当てられる、単調に増加する数値です。 各トランザクションには、一意のコミット タイムスタンプが設定されます。  
  
 行が削除または変更されるときは、その行がデータ ファイル内で実際に削除または変更されるのではなく、デルタ ファイルという別の種類のファイルによって、削除された行の追跡が行われます。 更新操作は、それぞれの行の削除操作と挿入操作の組み合わせとして処理されます。 これにより、データ ファイルでランダム IO が発生しないようになっています。  
  
### <a name="the-delta-file"></a>デルタ ファイル  
 各データ ファイルには、同じトランザクション範囲を持つデルタ ファイルが対応付けられています。デルタ ファイルは、そのトランザクション範囲のトランザクションによって挿入された削除済みの行を追跡します。 このデータ ファイルとデルタ ファイルはチェックポイント ファイル ペア (CFP) と呼ばれます。これは Merge 操作の単位であるとともに、割り当てと割り当て解除の単位でもあります。 たとえば、トランザクション範囲 (100、200) に対応するデルタ ファイルには、範囲 (100、200) のトランザクションによって挿入された削除済みの行が格納されます。 データ ファイルと同様に、デルタ ファイルは順次アクセスされます。  
  
 行の削除時には、データ ファイルから行が削除されるのではなく、その行への参照が、このデータ行が挿入されたトランザクション範囲に関連付けられているデルタ ファイルに追加されます。 削除対象のデータ行は既にデータ ファイルに存在するため、デルタ ファイルには参照情報 ( `{inserting_tx_id, row_id, deleting_tx_id }` ) が格納されるだけです。格納順序は、元の削除操作または更新操作のトランザクション ログの順序に従います。  
  
## <a name="populating-data-and-delta-files"></a>データ ファイルとデルタ ファイルの取り込み  
 オフライン チェックポイントと呼ばれるバックグラウンド スレッドにより、データ ファイルとデルタ ファイルが取り込まれます。 このスレッドは、メモリ最適化テーブルに対するコミットされたトランザクションが生成したトランザクション ログ レコードを読み取り、挿入および削除された行に関する情報を適切なデータ ファイルとデルタ ファイルに追加します。 ディスク ベース テーブルでは、チェックポイントの完了時にデータやインデックス ページがランダム I/O でフラッシュされますが、これとは異なり、メモリ最適化テーブルの永続化は連続的なバックグラウンド操作によって行われます。 トランザクションでは、それ以前のいずれかのトランザクションによって挿入された任意の行が削除または更新されることがあるため、複数のデルタ ファイルへのアクセスが発生します。 削除情報は常にデルタ ファイルの末尾に追加されます。 たとえば、下に示す図では、コミット タイムスタンプが 600 のトランザクションでは、1 つの新しい行が挿入され、コミット タイムスタンプが 150、250、および 450 のトランザクションによって挿入された行が削除されます。 4 つのファイル I/O 操作 (3 つは削除された行が対象で、1 つは新しく挿入された行が対象) はすべて、対応するデルタ ファイルとデータ ファイルに対する追加専用の操作です。  
  
 ![メモリ最適化テーブルの読み取りログ レコード。](../../database-engine/media/read-logs-hekaton.gif "メモリ最適化テーブルの読み取りログ レコード。")  
  
## <a name="accessing-data-and-delta-files"></a>データ ファイルとデルタ ファイルへのアクセス  
 データ ファイルとデルタ ファイルのペアにアクセスするのは次のような場合です。  
  
 オフライン チェックポイント スレッド  
 このスレッドでは、メモリ最適化データ行に対する挿入と削除を、対応するデータ ファイルとデルタ ファイルのペアに追加します。  
  
 マージ操作  
 この操作では、1 つ以上のデータ ファイルとデルタ ファイルのペアをマージして、新しいデータ ファイルとデルタ ファイルのペアを作成します。  
  
 クラッシュ後の復旧の処理中  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] を再起動するか、データベースがオンラインに戻ると、データ ファイルとデルタ ファイルのペアを使用してメモリ最適化データが取り込まれます。 デルタ ファイルは、対応するデータ ファイルから行を読み取るときに、削除された行のフィルターとして機能します。 データ ファイルとデルタ ファイルのペアは独立しているため、データをメモリに取り込む時間を削減するために、これらのファイルは並列処理で読み込まれます。 データがメモリに読み込まれると、インメモリ OLTP エンジンは、メモリ最適化データが完全になるように、まだチェックポイント ファイルで扱われていないアクティブなトランザクション ログ レコードを適用します。  
  
 復元操作の処理中  
 インメモリ OLTP のチェックポイント ファイルはデータベースのバックアップから作成され、1 つ以上のトランザクション ログ バックアップが適用されます。 クラッシュ後の復旧の場合と同様に、インメモリ OLTP エンジンはデータを並列処理でメモリに読み込むので、復旧時間への影響を最小限に抑えることができます。  
  
## <a name="merging-data-and-delta-files"></a>データ ファイルとデルタ ファイルのマージ  
 メモリ最適化テーブルのデータは、1 つ以上のデータ ファイルとデルタ ファイルのペア (チェックポイント ファイル ペアまたは CFP とも呼ばれます) に格納されます。 データ ファイルは挿入された行を格納し、デルタ ファイルは削除された行を参照します。 OLTP ワークロードの実行中、DML 操作によって行が更新、挿入、および削除されると、新しい行を保存するために新しい CFP が作成され、削除された行への参照がデルタ ファイルに追加されます。  
  
 以前に閉じられたすべての CFP と現在アクティブな CFP のメタデータは、ストレージ配列と呼ばれる内部の配列構造に格納されます。 これはサイズが 8,192 エントリに制限された CFP の配列です。 ストレージ配列内のエントリの順序は、トランザクション範囲に従います。 ストレージ配列内の CFP (およびログの末尾) は、メモリ最適化テーブルを持つデータベースの復旧に必要となるディスク上の状態を表します。  
  
 DML 操作を行うと、時間と共に、CFP の数が増加し、ストレージ配列が上限に近づくため、次の問題が発生します。  
  
-   削除された行。  削除された行はデータ ファイルに残りますが、対応するデルタ ファイルで削除済みとしてマークされます。 これらの行は不要なため、ストレージから削除されます。 削除された行が CFP から除去されていない場合は、領域が不必要に使用され、復旧時間が長くなります。  
  
-   ストレージ配列がいっぱいになる。 ストレージ配列に 8,000 個のエントリが割り当てられると (既存のマージを完了するため、またはマージを手動で実行できるように、配列には 192 個のエントリが予約されています)、持続性のあるメモリ最適化テーブルに対して新しい DML トランザクションを実行することはできなくなります。 残りのエントリは、チェックポイント操作とマージ操作にしか使用できません。 これにより、DML トランザクションで配列がいっぱいになるのを防ぎ、既存のファイルのマージと配列内の領域の再利用に備えて一部のエントリが確保されます。  
  
-   ストレージ配列操作のオーバーヘッド。 内部プロセスでは、削除された行に関する情報を追加するためにデルタ ファイルを見つける必要がある場合などに、ストレージ配列を検索します。 このような操作のコストは、エントリ数が増えるにつれて増加します。  
  
 効率の低下を防ぐために、閉じている古い CFP は、後で説明するマージ ポリシーに基づいてマージされます。結果のストレージ配列は圧縮され、CFP の数が少なくなりますが、データ セットは変わりません。  
  
 データベース内の持続性のあるすべてのテーブルのメモリ内サイズの合計は 250 GB を超えないようにする必要があります。 最大 250 GB のメモリを使用する持続性のあるテーブルでは、挿入操作、削除操作、および更新操作が想定されており、平均 500 GB のストレージ領域が必要となります。 500 GB のストレージ領域をサポートするには、メモリ最適化ファイル グループ内の 4,000 組のデータ ファイルとデルタ ファイルのペアが必要です。  
  
 データベース操作が短期間に集中すると、チェックポイント操作とマージ操作のラグが発生し、必要なデータ ファイルとデルタ ファイルのペアの数が増加します。 短期間に急増するデータベース操作に対応するために、ストレージ システムでは、最大 8,000 組のデータ ファイルとデルタ ファイルのペアを合計 1 TB までのストレージに割り当てることができます。 この制限に達すると、チェックポイント操作の遅延が解消されるまで、データベースでは新しいトランザクションが許可されません。 メモリ内の持続性のあるテーブルのサイズが長期間にわたって 250 GB を超える場合、8,000 組のファイル ペアの制限に達することがあります。  
  
 マージ操作は、内部で定義されているマージ ポリシーに基づいて、1 つ以上の閉じている隣接 CFP (マージ ソースと呼ばれます) を入力として受け取り、1 つの結果 CFP (マージ ターゲットと呼ばれます) を生成します。 ソース CFP の各デルタ ファイル内のエントリは、対応するデータ ファイルから行をフィルター選択して、不要なデータ行を削除するために使用されます。 ソース CFP の残りの行は、1 つのターゲット CPF に統合されます。 マージが完了すると、結果の CFP でソース CFP (マージ ソース) が置き換えられます。 マージ ソースの CFP は、移行フェーズを経た後でストレージから削除されます。  
  
 次の例では、メモリ最適化テーブルのファイル グループに、タイムスタンプが 500 の時点でデータ ファイルとデルタ ファイルのペアが 4 組あり、以前のトランザクションからのデータが含まれています。 たとえば、最初のデータ ファイルの行は、100 より大きく 200 以下のタイムスタンプを持つトランザクションに対応します。この範囲は (100, 200] と表すこともできます。 2 番目と 3 番目のデータ ファイルは、削除済みとしてマークされている行を考慮すると、入力率が 50% 未満になっています。 これらの 2 つの CFP をマージ操作で結合し、タイムスタンプが 200 より大きく 400 以下 (2 つのファイルの結合範囲) のトランザクションを含む新しい CFP を作成します。 すると、範囲が (500, 600] のもう 1 つの CFP と、トランザクション範囲が (200, 400] の空でないデルタ ファイルが現れます。これは、マージ操作と同時に、ソース CFP から他の行を削除するといったトランザクション アクティビティを実行できることを示しています。  
  
 ![図はメモリ最適化テーブル ファイル グループを示している](../../database-engine/media/storagediagram-hekaton.png "図はメモリ最適化テーブル ファイル グループを示している")  
  
 バックグラウンド スレッドでは、閉じているすべての CFP がマージ ポリシーを使用して評価され、該当する CFP に対して 1 つ以上のマージ要求が開始されます。 これらのマージ要求は、オフライン チェックポイント スレッドによって処理されます。 マージ ポリシーの評価は定期的に実行され、チェックポイントが閉じられるときにも行われます。  
  
### <a name="includesssql14includessssql14-mdmd-merge-policy"></a>[!INCLUDE[ssSQL14](../../../includes/sssql14-md.md)] マージ ポリシー  
 [!INCLUDE[ssSQL14](../../../includes/sssql14-md.md)] には、次のマージ ポリシーが実装されています。  
  
-   削除済みの行を考慮したうえで 2 つ以上の連続する CFP が統合可能であり、結果の行が適切なサイズの 1 つの CFP に収まる場合、マージがスケジュールされます。 CFP の適切なサイズは次のように決定されます。  
  
    -   コンピューターのメモリが 16G B 以下の場合は、データ ファイルは 16 MB で、デルタ ファイルは 1 MB です。  
  
    -   コンピューターのメモリが 16 GB を上回る場合は、データ ファイルは 128 MB で、デルタ ファイルは 16 MB です。  
  
-   データ ファイルが 256 MB を上回っており、半分以上の行が削除済みの場合は、単一の CFP を自己マージすることができます。 データ ファイルは 128 MB を上回る可能性があります。たとえば、1 つのトランザクションまたは複数の同時実行トランザクションが大量の INSERT や UPDATE を実行する場合、1 つのトランザクションが複数の CFP にまたがることはできないため、適切なサイズを上回ってデータ ファイルを拡張することが強制されます。  
  
 次に、マージ ポリシーに従った CFP のマージの例をいくつか示します。  
  
|隣接する CFP ソース ファイル (入力 %)|マージ対象|  
|-------------------------------------------|---------------------|  
|CFP0 (30%)、CFP1 (50%)、CFP2 (50%)、CFP3 (90%)|(CFP0、CFP1)<br /><br /> CFP2 は選択されません。これを含めると、結果のデータ ファイルが適切なサイズの 100% を超えることになります。|  
|CFP0 (30%)、CFP1 (20%)、CFP2 (50%)、CFP3 (10%)|(CFP0、CFP1、CFP2)。 ファイルは左から選択されます。<br /><br /> CTP3 は選択されません。これを含めると、結果のデータ ファイルが適切なサイズの 100% を超えることになります。|  
|CFP0 (80%)、CFP1 (30%)、CFP2 (10%)、CFP3 (40%)|(CFP1、CFP2、CFP3)。 ファイルは左から選択されます。<br /><br /> CFP0 はスキップされます。これを CFP1 と結合すると、結果のデータ ファイルが適切なサイズの 100% を超えることになるためです。|  
  
 空き領域のある CFP がすべてマージに適合するとは限りません。 たとえば、2 つの隣接する CFP の入力率が 60% の場合、これらはマージの対象にならないため、各 CFP の 40% のストレージは未使用になります。 最悪のケースは、すべての CFP の入力率が 50% になり、ストレージが 50% しか使用されない場合です。 CFP がマージ対象にならず、削除済みの行がストレージに存在していても、それらの削除済みの行は、インメモリ ガベージ コレクションによって既にメモリからは削除されている場合があります。 ストレージとメモリの管理は、ガベージ コレクションから独立しています。 アクティブな CFP (すべての CFP が更新されるわけではありません) から取得されたストレージは、最大でメモリ内の持続性のあるテーブルのサイズの 2 倍になる可能性があります。  
  
 手動マージを呼び出すことによって明示的に実行することができます必要な場合、 [sys.sp_xtp_merge_checkpoint_files &#40;TRANSACT-SQL&#41;](/sql/relational-databases/system-stored-procedures/sys-sp-xtp-merge-checkpoint-files-transact-sql)します。  
  
### <a name="life-cycle-of-a-cfp"></a>CFP のライフ サイクル  
 CPF は、割り当てが解除されるまでにいくつかの状態を遷移します。 任意の時点で、Cfp は、次のフェーズのいずれかでは。PRECREATED、UNDER CONSTRUCTION、ACTIVE、MERGE TARGET、MERGED SOURCE、REQUIRED FOR BACKUP/HA、IN TRANSITION TO TOMBSTONE、および廃棄 (tombstone)。 これらのフェーズの説明については、「[sys.dm_db_xtp_checkpoint_files &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql)」を参照してください。  
  
 さまざまな状態にある CFP によって取得されるストレージを考慮に入れると、持続性のあるメモリ最適化テーブルによって取得されるストレージ全体のサイズは、メモリ内のテーブルのサイズの 2 倍を大きく超える可能性があります。 DMV [sys.dm_db_xtp_checkpoint_files &#40;TRANSACT-SQL&#41; ](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql)をフェーズは、メモリ最適化ファイルグループ内のすべての Cfp を一覧表示するクエリを実行できます。 CFP を MERGE SOURCE 状態から TOMBSTONE に移行すると、ガベージ コレクションが最終的に 5 個のチェックポイントを使用する可能性があり、データベースが完全復旧モデルまたは一括ログ復旧モデルを使用するように構成されている場合は、各チェックポイントの後にトランザクション ログ バックアップが続きます。  
  
 手動でチェックポイントとログのバックアップを強制してガベージ コレクションを早めることもできますが、その場合は 5 つの空の CFP (データ ファイルとデルタ ファイルのペアが 5 つ、各データ ファイルのサイズは 128 MB) が追加されます。 実稼動環境のシナリオでは、バックアップ方法の一環として実行される自動チェックポイントとログ バックアップにより、CFP はこれらのフェーズをシームレスに移行し、手動による操作は必要ありません。 ガベージ コレクション プロセスが実行されると、その影響として、メモリ最適化テーブルのあるデータベースのストレージ サイズがメモリ内のサイズに比べて大きくなる可能性があります。 CFP にとって、持続性のあるメモリ最適化テーブルのサイズがメモリ内サイズの 4 倍までになるのは珍しいことではありません。  
  
## <a name="see-also"></a>参照  
 [メモリ最適化オブジェクト用ストレージの作成と管理](creating-and-managing-storage-for-memory-optimized-objects.md)  
  
  
