---
title: メモリ最適化テーブルのメモリ必要量の推定 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 5c5cc1fc-1fdf-4562-9443-272ad9ab5ba8
author: CarlRabeler
ms.author: carlrab
manager: craigg
ms.openlocfilehash: cbd8a79bf9d881d2d4c9055531bac2e290f202a4
ms.sourcegitcommit: 495913aff230b504acd7477a1a07488338e779c6
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/06/2019
ms.locfileid: "68811010"
---
# <a name="estimate-memory-requirements-for-memory-optimized-tables"></a>メモリ最適化テーブルのメモリ必要量の推定
  新しい[!INCLUDE[hek_2](../../includes/hek-2-md.md)]メモリ最適化テーブルを作成するか、既存のディスクベーステーブルをメモリ最適化テーブルに移行するかにかかわらず、十分な量のサーバーをプロビジョニングできるように、各テーブルのメモリのニーズを十分に見積もることが重要です。量. ここでは、メモリ最適化テーブルのデータを保持するために必要とされるメモリの量を推定する方法について説明します。  
  
 ディスク ベース テーブルをメモリ最適化テーブルに移行することを検討している場合は、このトピックを読み進める前に、どのテーブルを移行するのが最善であるかを示す「 [テーブルまたはストアド プロシージャをインメモリ OLTP に移植する必要があるかどうかの確認](determining-if-a-table-or-stored-procedure-should-be-ported-to-in-memory-oltp.md) 」というトピックを参照してください。 「 [インメモリ OLTP への移行](migrating-to-in-memory-oltp.md) 」に掲載されているすべてのトピックには、ディスク ベース テーブルからメモリ最適化テーブルへの移行に関するガイダンスが掲載されています。  
  
## <a name="sections-in-this-topic"></a>このトピックのセクション  
  
-   [サンプルのメモリ最適化テーブル](#bkmk_ExampleTable)  
  
-   [テーブルに対応するメモリ](#bkmk_MemoryForTable)  
  
-   [インデックスに対応するメモリ](#bkmk_IndexMeemory)  
  
-   [行のバージョン管理に対応するメモリ](#bkmk_MemoryForRowVersions)  
  
-   [テーブル変数に対応するメモリ](#bkmk_TableVariables)  
  
-   [成長に対応するメモリ](#bkmk_MemoryForGrowth)  
  
##  <a name="bkmk_ExampleTable"></a> サンプルのメモリ最適化テーブル  
 次のメモリ最適化テーブルのスキーマを考えてみます。  
  
```sql  
  
CREATE TABLE t_hk (  
col1 int NOT NULL PRIMARY KEY NONCLUSTERED,  
col2 int NOT NULL INDEX t1c2_index   
     HASH WITH (bucket_count = 5000000),  
col3 int NOT NULL INDEX t1c3_index   
     HASH WITH (bucket_count = 5000000),  
col4 int NOT NULL INDEX t1c4_index   
     HASH WITH (bucket_count = 5000000),  
col5 int NOT NULL INDEX t1c5_index NONCLUSTERED,  
col6 char (50) NOT NULL,  
col7 char (50) NOT NULL,   
col8 char (30) NOT NULL,   
col9 char (50) NOT NULL  
     WITH (memory_optimized = on)  
GO  
  
```  
  
 このスキーマを使用して、このメモリ最適化テーブルで必要とされる最小メモリを決定します。  
  
##  <a name="bkmk_MemoryForTable"></a> テーブルに対応するメモリ  
 メモリ最適化テーブルの行は、次の 3 つの部分から形成されています。  
  
-   **タイムスタンプ**   
    行のヘッダー/タイムスタンプ = 24 バイトです。  
  
-   **インデックス ポインター**   
    テーブル内の各ハッシュ インデックスにある各行には、インデックス内の次の行を指す 8 バイトのアドレス ポインターが含まれています。  ここでは 4 つのインデックスが存在しているため、各行はインデックス ポインターに 32 バイト (インデックスごとに 8 バイトのポインター) を割り当てます。  
  
-   **データ**   
    行のデータ部分のサイズは、各データ列に対応する型サイズの合計によって決まります。  このテーブルには、4 バイトの整数が 5 個、50 バイトの文字列型の列が 3 個、30 バイトの文字列型の列が 1 個あります。  したがって、各行のデータ部分は、4 + 4 + 4 + 4 + 4 + 50 + 50 + 50 + 30、つまり 200 バイトです。  
  
 以下は、メモリ最適化テーブル内に存在する 5,000,000 (500 万) 行のサイズの計算です。 データ行で使用される合計メモリは、次のように推定されます。  
  
 **テーブルの行のメモリ**  
  
 上記の計算結果から、メモリ最適化テーブル内にある各行のサイズは 24 + 32 + 200、つまり 256 バイトです。  500 万の行があるため、テーブルは 5,000,000 * 256 バイト、つまり 1,280,000,000 バイト、約 1.28 GB を使用します。  
  
##  <a name="bkmk_IndexMeemory"></a> インデックスに対応するメモリ  
 **各ハッシュインデックスのメモリ**  
  
 各ハッシュ インデックスは、8 バイトのアドレス ポインターから成るハッシュの配列です。  配列のサイズは、そのインデックスの一意のインデックス値の数に基づいて適切に決定できます。たとえば、一意の Col2 の値の数を、t1c2_index の配列サイズを求めるための適切な出発点として使用することができます。 大きすぎるハッシュ配列は、メモリを浪費します。  小さすぎるハッシュ配列を使用する場合は、パフォーマンスが低下します。同じインデックスへとハッシュされるインデックス値が多くなり、非常に多くの競合が発生するためです。  
  
 ハッシュ インデックスは、次のように等値参照を実行する場合は非常に高速です。  
  
```sql  
  
SELECT * FROM t_hk  
   WHERE Col2 = 3  
  
```  
  
 非クラスター化インデックスは、次のように範囲参照を実行する場合はより高速になります。  
  
```sql  
  
SELECT * FROM t_hk  
   WHERE Col2 >= 3  
  
```  
  
 ディスク ベース テーブルを移行する場合は、t1c2_index インデックスに対応する一意の値の数を決定するために、次を使用できます。  
  
```sql  
  
SELECT COUNT(DISTINCT [Col2])  
  FROM t_hk  
  
```  
  
 新しいテーブルを作成する場合は、配列のサイズを推測するか、配置を実行する前にテストからデータを収集する必要があります。  
  
 [!INCLUDE[hek_2](../../includes/hek-2-md.md)] メモリ最適化テーブル内でのハッシュ インデックスの動作方法の詳細については、「 [Hash Indexes](../../database-engine/hash-indexes.md)」(ハッシュ インデックス) を参照してください。  
  
 **注:** ハッシュインデックスの配列サイズを即座に変更することはできません。 ハッシュ インデックスの配列サイズを変更するには、テーブルを削除して bucket_count の値を変更し、そのテーブルを再作成する必要があります。  
  
 **ハッシュインデックスの配列サイズの設定**  
  
 ハッシュ配列のサイズはによっ`(bucket_count= <value>)`て\<設定されます。 > の値は0より大きい整数値です。 > \<値が2の累乗でない場合、実際の bucket_count は、次に最も近い2のべき乗に切り上げられます。  この例のテーブル (bucket_count = 500万) では、500万は2のべき乗ではないため、実際のバケット数は 8388608 (2<sup>23</sup>) に切り上げられます。  ハッシュ配列が必要とするメモリを計算するときは、5,000,000 ではなく、この数値を使用する必要があります。  
  
 したがって、この例の各ハッシュ配列で必要とされるメモリは次のようになります。  
  
 8388608 * 8 = 2<sup>23</sup> \* 8 = 2<sup>23</sup> \* 2<sup>3</sup> = 2<sup>26</sup> = 67108864 または約 64 MB。  
  
 3 つのハッシュ インデックスが存在するため、ハッシュ インデックスで必要とされるメモリは 3 * 64MB = 192MB です。  
  
 **非クラスター化インデックスのメモリ**  
  
 非クラスター化インデックスは、インデックス値を含む内部ノードと後続のノードへのポインターを含む BTrees として実装されます。  リーフ ノードは、インデックス値と、メモリ内にあるテーブルの行を指すポインターを保持しています。  
  
 ハッシュインデックスとは異なり、非クラスター化インデックスには固定バケットサイズがありません。 インデックスは、データと共に動的に拡張または圧縮されます。  
  
 非クラスター化インデックスに必要なメモリは、次のように計算できます。  
  
-   **非リーフ ノードに割り当てられるメモリ**   
    標準的な構成では、非リーフ ノードに割り当てられるメモリが、インデックスによって取得されるメモリ全体に占める割合は非常に小さいものです。 これは非常に小さい割合であり、無視しても安全です。  
  
-   **リーフ ノードに割り当てられるメモリ**   
    リーフ ノードにはテーブル内に存在する一意のキーごとに 1 行のデータがあり、リーフ ノードは、その一意のキーを持つデータ行を指します。  同じキーを持つ複数の行がある場合 (つまり、一意ではない非クラスター化インデックスがある場合)、インデックスリーフノードには、互いにリンクされている他の行を含む行の1つだけが存在します。  したがって、必要とされるメモリ全体は、次のように近似できます。   
    memoryForNonClusteredIndex = (pointerSize + sum(keyColumnDataTypeSizes)) * rowsWithUniqueKeys  
  
 非クラスター化インデックスは、次のクエリによって例示されるように、範囲参照に使用する場合に最適です。  
  
```sql  
  
SELECT * FROM t_hk  
   WHERE c2 > 5  
```  
  
##  <a name="bkmk_MemoryForRowVersions"></a> 行のバージョン管理に対応するメモリ  
 ロックを回避するために、インメモリ OLTP は行を更新または削除するときに、オプティミスティック コンカレンシーを使用します。 これは、行を更新するときに、行の追加バージョンが作成されることを意味します。 以前のバージョンを使用する可能性のあるすべてのトランザクションが実行を完了するまでは、システムは以前のバージョンを使用可能な状態に保ちます。 行を削除する場合も、システムは更新の場合に似た方法で動作し、以前のバージョンが不要になるまでは、以前のバージョンを使用可能な状態に保ちます。 読み取りと挿入を実行する場合は、行の追加バージョンは作成されません。  
  
 メモリ内にはいつでも多数の追加行が存在している可能性があり、それらの行は自らのメモリを解放するガベージ コレクション サイクルを待機しているため、これらの追加の行を収容するために十分なメモリを用意する必要があります。  
  
 追加の行の数を推定するには、1 秒あたりの行の更新と削除に関するピークの数値を求め、その値に、最も長いトランザクションが要する秒数 (最小値は 1) を掛けます。  
  
 この積に、行サイズを掛けると、行のバージョン管理に必要とされるバイト数を得ることができます。  
  
 `rowVersions = durationOfLongestTransactionInSeconds * peakNumberOfRowUpdatesOrDeletesPerSecond`  
  
 古い行のメモリ必要量を推定するには、古い行の数に、メモリ最適化テーブルの行のサイズを掛けます (上記[の表の「メモリ](#bkmk_MemoryForTable)」を参照してください)。  
  
 `memoryForRowVersions = rowVersions * rowSize`  
  
##  <a name="bkmk_TableVariables"></a> テーブル変数に対応するメモリ  
 テーブル変数に対応するメモリは、テーブル変数がスコープ外になる場合にのみ解放されます。 テーブル変数から削除された行 (更新の一部として削除された行を含む) には、ガベージ コレクションは適用されません。 テーブル変数がスコープを終了するまでメモリは解放されません。  
  
 プロシージャ スコープとは対照的に、多くのトランザクションで使用される大きな SQL バッチで定義されるテーブル変数は、多くのメモリを消費することがあります。 ガベージ コレクションの対象ではないため、テーブル変数内にある削除された行は多くのメモリを使用し、パフォーマンスが低下することがあります。読み取り操作では、削除されたこれらの行をスキャンで通過させる必要があるためです。  
  
##  <a name="bkmk_MemoryForGrowth"></a> 成長に対応するメモリ  
 上記の各計算では、現在存在しているテーブルに対応するメモリ必要量を推定しています。 このメモリに加えて、テーブルが成長することを推定し、その成長を収容するために十分なメモリを用意する必要があります。  たとえば、10% の成長を予測している場合は、上記の結果に 1.1 を掛けて、テーブルで必要とされる合計メモリを得ることができます。  
  
## <a name="see-also"></a>関連項目  
 [インメモリ OLTP への移行](migrating-to-in-memory-oltp.md)  
  
  
