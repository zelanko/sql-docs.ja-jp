---
title: トランザクション分離レベル (ODBC) |Microsoft Docs
ms.custom: seo-dt-2019
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
author: MightyPen
ms.author: genemi
ms.openlocfilehash: e11a0d76fc4a2daece7b6f4f50761d40933792be
ms.sourcegitcommit: baa40306cada09e480b4c5ddb44ee8524307a2ab
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/06/2019
ms.locfileid: "73637216"
---
# <a name="transaction-isolation-levels-odbc"></a>トランザクション分離レベル (ODBC)
*トランザクション分離レベル*は、トランザクションの分離が成功する範囲の尺度です。 特に、トランザクション分離レベルは、次のような場合に存在するかどうかによって定義されます。  
  
-   **ダーティリード***ダーティリード*は、トランザクションがまだコミットされていないデータを読み取るときに発生します。 たとえば、トランザクション1が行を更新するとします。 トランザクション2は、トランザクション1が更新をコミットする前に、更新された行を読み取ります。 トランザクション1が変更をロールバックすると、トランザクション2は、存在しないと見なされるデータを読み取ります。  
  
-   **反復不能読み取り***反復不能読み取り*は、トランザクションが同じ行を2回読み取るときに発生しますが、毎回異なるデータを取得します。 たとえば、トランザクション1が行を読み取るとします。 トランザクション2は、その行を更新または削除し、更新または削除をコミットします。 トランザクション1が行を再度取得した場合は、異なる行値を取得するか、その行が削除されたことを検出します。  
  
-   **ファントム***ファントム*とは、検索条件に一致するものの、最初に表示されない行のことです。 たとえば、一部の検索条件を満たす行のセットをトランザクション1が読み取るとします。 トランザクション2は、トランザクション1の検索条件に一致する新しい行を (更新または挿入によって) 生成します。 トランザクション1が行を読み取るステートメントを再実行すると、別の行セットが取得されます。  
  
 4つのトランザクション分離レベル (SQL-92 で定義) は、これらの現象の観点から定義されています。 次の表では、"X" は発生する可能性がある各現象を示しています。  
  
|トランザクション分離レベル|ダーティリード|反復不能読み取り|幻|  
|---------------------------------|-----------------|-------------------------|--------------|  
|READ UNCOMMITTED|×|×|×|  
|READ COMMITTED|--|×|×|  
|REPEATABLE READ|--|--|×|  
|Serializable|--|--|--|  
  
 次の表では、DBMS がトランザクション分離レベルを実装する簡単な方法について説明します。  
  
> [!IMPORTANT]  
>  ほとんどの Dbms では、同時実行性を向上させるために、より複雑なスキームが使用されます。 これらの例は、説明のみを目的として提供されています。 特に、ODBC では、特定の Dbms がトランザクションを相互に分離する方法は規定されていません。  
  
|トランザクションの分離|考えられる実装|  
|---------------------------|-----------------------------|  
|READ UNCOMMITTED|トランザクションは相互に分離されていません。 DBMS で他のトランザクション分離レベルがサポートされている場合は、それらのレベルを実装するために使用するメカニズムが無視されます。 そのため、他のトランザクションに悪影響が及ばないように、読み取りのコミットされていないレベルで実行されているトランザクションは、通常、読み取り専用です。|  
|READ COMMITTED|トランザクションは、他のトランザクションによってロックされている行のロックが解除されるまで待機します。これにより、"ダーティ" データを読み取ることができなくなります。<br /><br /> トランザクションは、現在の行で読み取りロックを保持している場合 (行のみを読み取る場合)、または書き込みロック (行を更新または削除する場合) を保持して、他のトランザクションが更新または削除されないようにします。 トランザクションは、現在の行から移動するときに、読み取りロックを解放します。 コミットまたはロールバックされるまで、書き込みロックを保持します。|  
|REPEATABLE READ|トランザクションは、他のトランザクションによってロックされている行のロックが解除されるまで待機します。これにより、"ダーティ" データを読み取ることができなくなります。<br /><br /> トランザクションは、アプリケーションに返されるすべての行に対して読み取りロックを保持し、挿入、更新、または削除を行うすべての行に対してロックを書き込みます。 たとえば、トランザクションに SQL ステートメントの**select \*** が含まれている場合、トランザクションはアプリケーションがフェッチした行を読み取りロックします。 トランザクションに、 **Status = ' CLOSED ' という SQL ステートメント DELETE FROM Orders**が含まれている場合、トランザクションはそれらを削除するときに行を書き込みます。<br /><br /> 他のトランザクションはこれらの行を更新または削除できないため、現在のトランザクションでは、反復不能な読み取りを回避します。 トランザクションは、コミットまたはロールバックされるときにロックを解放します。|  
|Serializable|トランザクションは、他のトランザクションによってロックされている行のロックが解除されるまで待機します。これにより、"ダーティ" データを読み取ることができなくなります。<br /><br /> トランザクションは、影響を与える行の範囲に対して読み取りロック (行の読み取りのみ) または書き込みロック (行の更新または削除が可能な場合) を保持します。 たとえば、トランザクションに SQL ステートメントの**select \*** が含まれている場合、その範囲は orders テーブル全体です。トランザクションによってテーブルがロックされ、新しい行を挿入することは許可されません。 トランザクションに、 **status = ' closed ' という状態の SQL ステートメント DELETE FROM Orders**が含まれている場合、範囲は "closed" という状態のすべての行になります。トランザクションでは、Orders テーブル内のすべての行が "CLOSED" という状態でロックされます。この場合、結果の行の状態が "CLOSED" になるように行を挿入または更新することはできません。<br /><br /> 他のトランザクションは範囲内の行を更新または削除できないため、現在のトランザクションでは、反復不能な読み取りを回避します。 他のトランザクションは範囲内に行を挿入できないため、現在のトランザクションではファントムが回避されます。 トランザクションは、コミットまたはロールバックされるときにロックを解放します。|  
  
 トランザクション分離レベルは、トランザクションの変更を表示するトランザクションの機能に影響を与えないことに注意してください。トランザクションでは、自分が行った変更が常に表示されます。 たとえば、トランザクションが2つの**UPDATE**ステートメントで構成されている場合、最初のステートメントではすべての従業員の支払いが10% 発生し、2番目のステートメントによって、最大金額を超える従業員の支払いが設定されます。 これは1つのトランザクションとしてのみ成功します。これは、2番目の UPDATE ステートメントで最初の**UPDATE**ステートメントの結果を確認できるためです。
