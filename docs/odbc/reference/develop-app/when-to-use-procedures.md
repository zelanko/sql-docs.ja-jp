---
title: プロシージャを使用するタイミング |Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQL statements [ODBC], procedures
- procedures [ODBC], about procedures
ms.assetid: 7dc9e327-dd54-4b10-9f66-9ef5c074f122
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 31aeea226bc8c8aa41f748d1d9a97d55147c4d67
ms.sourcegitcommit: e042272a38fb646df05152c676e5cbeae3f9cd13
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/27/2020
ms.locfileid: "81289099"
---
# <a name="when-to-use-procedures"></a>プロシージャを使用する場合
プロシージャの使用にはさまざまな利点があります。これは、プロシージャを使用することによって、アプリケーションからデータソースに SQL ステートメントを移動するという事実に基づいています。 アプリケーションの残りの部分は、相互運用可能なプロシージャ呼び出しです。 次のような利点があります。  
  
-   **パフォーマンス**プロシージャは、通常、SQL ステートメントを実行する最速の方法です。 準備実行と同様に、ステートメントは2つの個別の手順でコンパイルおよび実行されます。 準備された実行とは異なり、プロシージャは実行時にのみ実行されます。 これらは、別の時間にコンパイルされます。  
  
-   **ビジネスルール***ビジネスルール*とは、企業が業務を行う方法に関するルールのことです。 たとえば、Sales Person というタイトルのユーザーのみが、新しい販売注文を追加できます。 これらのルールをプロシージャに配置すると、アプリケーションコードを変更することなく、アプリケーションによって呼び出されるプロシージャを書き直すことで、個々の企業が垂直アプリケーションをカスタマイズできます。 たとえば、注文エントリアプリケーションでは、固定された数のパラメーターを使用して**Insertorder**プロシージャを呼び出すことができます。**Insertorder**の実装方法は、会社によって異なります。  
  
-   **Replaceability**手順におけるビジネスルールの配置に密接に関連しているのは、アプリケーションを再コンパイルしなくてもプロシージャを置き換えることができるということです。 企業がアプリケーションを購入してインストールした後にビジネスルールが変更された場合、会社はそのルールを含む手順を変更できます。 アプリケーションの観点からは、何も変更されていません。特定のタスクを実行するために、特定のプロシージャを呼び出します。  
  
-   **DBMS 固有の SQL**プロシージャを使用すると、アプリケーションは DBMS 固有の SQL を利用し、相互運用可能な状態を維持することができます。 たとえば、SQL のフロー制御ステートメントをサポートする DBMS 上のプロシージャは、エラーからトラップして復旧する場合がありますが、フロー制御ステートメントをサポートしていない DBMS 上のプロシージャは、単にエラーを返すことがあります。  
  
-   **トランザクションの残りの手順**一部のデータソースでは、トランザクションがコミットまたはロールバックされると、接続で準備されたすべてのステートメントのアクセスプランが削除されます。 データソースに永続的に格納されているプロシージャに SQL ステートメントを配置すると、ステートメントはトランザクションのままになります。 準備された状態、部分的に準備された状態、準備解除済みの状態のいずれであっても、DBMS 固有の状態になります。  
  
-   **独立**した開発プロシージャは、アプリケーションの他の部分とは別に開発できます。 大企業では、これにより、高度に特殊化されたプログラマのスキルをさらに活用する方法が提供される可能性があります。 言い換えると、アプリケーションプログラマはユーザーインターフェイスコードを記述し、データベースプログラマはプロシージャを記述できます。  
  
 プロシージャは、通常、垂直およびカスタムアプリケーションで使用されます。 これらのアプリケーションは、固定されたタスクを実行する傾向があり、プロシージャ呼び出しをハードコーディングすることができます。 たとえば、注文エントリアプリケーションでは、 **Insertorder**、 **deleteorder**、 **Updateorder**、および**getorders**というプロシージャを呼び出すことができます。  
  
 汎用アプリケーションからプロシージャを呼び出す理由はほとんどありません。 プロシージャは、通常、特定のアプリケーションのコンテキストでタスクを実行するように記述されているので、汎用アプリケーションには使用しません。 たとえば、スプレッドシートには、先ほど説明した**Insertorder**プロシージャを呼び出す理由がありません。 さらに、汎用アプリケーションでは、ステートメントの実行を高速化するために、実行時にプロシージャを作成しないようにする必要があります。準備されたまたは直接実行よりも遅くなる可能性が高いだけでなく、DBMS 固有の SQL ステートメントも必要です。  
  
 この例外は、アプリケーション開発環境です。多くの場合、プログラマはプロシージャを実行する SQL ステートメントを作成し、プログラマがプロシージャをテストする方法を提供できます。 このような環境では、 **Sqlprocedures**を呼び出して、使用可能なプロシージャと**SQLProcedureColumns**を一覧表示し、入力、入出力、出力パラメーター、プロシージャの戻り値、およびプロシージャによって作成されたすべての結果セットの列を一覧表示します。 ただし、このような手順は、各データソースで事前に開発しておく必要があります。これを行うには、DBMS 固有の SQL ステートメントが必要です。  
  
 プロシージャの使用には、主に3つの欠点があります。 1つ目の方法は、アプリケーションを実行する DBMS ごとにプロシージャを記述してコンパイルする必要があることです。 これはカスタムアプリケーションでは問題ではありませんが、さまざまな Dbms で実行するように設計された垂直アプリケーションの開発と保守の時間を大幅に短縮することができます。  
  
 2つ目の欠点は、多くの Dbms がプロシージャをサポートしていないことです。 この場合も、多くの Dbms を使用して実行するように設計された垂直アプリケーションでは、問題が発生する可能性が高くなります。 プロシージャがサポートされているかどうかを判断するために、アプリケーションは SQL_PROCEDURES オプションを指定して**SQLGetInfo**を呼び出します。  
  
 3番目の欠点は、特にアプリケーション開発環境に適用されますが、ODBC ではプロシージャを作成するための標準的な文法が定義されていません。 つまり、アプリケーションは interoperably プロシージャを呼び出すことができますが、interoperably を作成することはできません。
