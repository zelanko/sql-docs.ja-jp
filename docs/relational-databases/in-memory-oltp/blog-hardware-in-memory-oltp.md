---
title: SQL インメモリ OLTP のハードウェア | Microsoft Docs
ms.custom: ''
ms.date: 03/28/2019
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
author: MightyPen
ms.author: genemi
monikerRange: =azuresqldb-current||=azuresqldb-mi-current||>=sql-server-2016||>=sql-server-linux-2017||=sqlallproducts-allversions
ms.openlocfilehash: 21293308f2b21d0a41cca901a084d65ca0250573
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/15/2019
ms.locfileid: "67951137"
---
# <a name="hardware-considerations-for-in-memory-oltp-in-sql-server"></a>SQL Server におけるインメモリ OLTP のハードウェアに関する考慮事項

インメモリ OLTP では、従来のディスク ベース テーブルと異なる方法でメモリとディスクを使用します。 インメモリ OLTP で見られるパフォーマンスの向上は、使用するハードウェアによって異なります。 このブログの投稿では、全般的なハードウェアのさまざまな考慮事項について説明し、インメモリ OLTP で使用するハードウェアの汎用的なガイドラインを提供しています。

> [!NOTE]
> この記事は、2013 年 8 月 1 日に Microsoft SQL Server 2014 チームによって発行されたブログです。 このブログの Web ページは廃止されます。
>
> [SQL Server インメモリ OLTP](index.md)

<!--
    Here was the link to the blog. This blog was captured into this new article on 2018/11/30, by GeneMi (MightyPen).
    https://cloudblogs.microsoft.com/sqlserver/2013/08/01/hardware-considerations-for-in-memory-oltp-in-sql-server-2014/
    At least one pre-existing article that contained the obsolete blog link was:
        relational-databases\in-memory-oltp\sample-database-for-in-memory-oltp.md
-->

## <a name="cpu"></a>CPU

インメモリ OLTP では、高スループットの OLTP ワークロードをサポートするハイエンド サーバーは必要ありません。 CPU ソケットを 2 つ備えたミッドレンジ サーバーを使用することをお勧めします。 インメモリ OLTP によって実現されるスループットの向上により、2 つのソケットでビジネス ニーズを十分満たすと考えられます。

インメモリ OLTP を使用したハイパー スレッディングを有効にすることをお勧めします。 一部の OLTP ワークロードで、ハイパー スレッディングを使用する場合に最大 40% のパフォーマンスの向上が見られました。

## <a name="memory"></a>[メモリ]

メモリ最適化テーブルはすべて、完全にメモリ内に存在します。 そのため、データベースに対して実行されるワークロードに耐えられる、テーブル自体にとって十分な物理メモリを備える必要がありますが、実際に必要なメモリの量はワークロード次第です。出発点として、データ サイズの約 2 倍のメモリを利用できれば十分です。 ワークロードで従来のディスク ベース テーブルも処理される場合、バッファー プール用の十分なメモリも必要です。

所定のメモリ最適化テーブルで使用されるメモリの量を判断するには、次のクエリを実行します。

```sql
select object_name(object_id), * from sys.dm_db_xtp_table_memory_stats;
```

結果に、メモリ最適化テーブルとそのインデックスに使用されるメモリが示されます。 テーブル データには、ユーザー データと、トランザクションの実行でこれまでどおり必要になるすべての古い行のバージョンや、システムでまだクリーンアップされていないすべての古い行のバージョンが含まれます。 ハッシュ インデックスで使用されるメモリは一定です。テーブル内の行数に左右されません。

データベース全体がメモリに収まる必要がないことを、インメモリ OLTP を使用するときに留意する必要があります。 ホット データ (つまり、メモリ最適化テーブル) のサイズが 256 GB を超えない限り、数 TB 規模のデータベースを使用しても、インメモリ OLTP のメリットを享受できます。 単一のデータベースについて SQL Server で管理できるチェックポイント データ ファイルの最大数は、各ファイルを 128 MB とすると 4000 です。 理論上最大 512 GB となりますが、SQL Server がチェックポイント ファイルのマージに対応し、4000 ファイルの制限に達しないようにするために、マイクロソフトは最大 256 GB をサポートしています。 この制限はメモリ最適化テーブルのみに適用されます。同じ SQL Server データベース内の従来のディスク ベース テーブルには、このようなサイズ制限はありません。

非持続的メモリ最適化テーブル (NDT)、つまり DURABILITY=SCHEMA_ONLY が設定されたメモリ最適化テーブルは、ディスクに保存されません。 NDT は、チェックポイント ファイルの数で制限されませんが、256 GB のみがサポートされます。 この記事の残りの部分で説明するログとデータ ドライブに関する考慮事項は、持続性のないテーブルには適用されません。このようなテーブルでは、データがメモリ内にのみ存在するためです。

## <a name="log-drive"></a>ログ ドライブ

メモリ最適化テーブルに関連するログ レコードは、その他の SQL Server のログ レコードと共に、データベースのトランザクション ログに書き込まれます。

トランザクションが長期間待機する必要がないためにログ IO の競合を回避できるように、低待機時間のドライブにログ ファイルを配置することが常に重要です。 システムは、最も低速なコンポーネント (アムダールの法則) と同じ速度で実行されます。 インメモリ OLTP を実行するときに、ログ IO デバイスがボトルネックにならないようにする必要があります。 低待機時間の、少なくとも SSD の記憶装置を使用することをお勧めします。

メモリ最適化テーブルでは、インデックス操作も UNDO レコードもログに記録されないため、使用されるログ帯域幅が、ディスク ベース テーブルよりも少なくなります。 このことは、ログ IO の競合を軽減するために役立ちます。

## <a name="data-drive"></a>データ ドライブ

チェックポイント ファイルを使用したメモリ最適化テーブルの持続には、ストリーミング IO が使用されます。 そのため、これらのファイルでは、低待機時間または高速なランダム IO のドライブは不要です。 代わりに、これらのドライブの主な要因は、ホスト バス アダプター (HBA) のシーケンシャル IO と帯域幅の速度になります。 そのため、チェックポイント ファイル用の SSD は必要ありません。シーケンシャル IO 速度が要件を満たしている限り、チェックポイント ファイルは高パフォーマンスのスピンドル (SAS など) に配置できます。

速度要件を決定する上で最も重要な要因が、サーバー再起動時のRTO [目標復旧時間] です。 データベースの復旧中に、メモリ最適化テーブルのすべてのデータをディスクからメモリに読み込む必要があります。 データベースの復旧は、IO サブシステムの順次読み込みの速度で行わるため、ディスクでがボトルネックになります。

厳密な RTO の要件を満たすには、MEMORY_OPTIMIZED_DATA ファイル グループに複数のコンテナーを追加することで、複数のディスクにチェックポイント ファイルを展開することをお勧めします。 SQL Server では、複数のドライブからのチェックポイント ファイルの並列読み込みをサポートしています。つまり、復旧は、ドライブの集計速度で行われます。

ディスクの容量の点では、2 から 3 倍のサイズのメモリ最適化テーブルを利用可能にすることをお勧めします。

## <a name="see-also"></a>参照

[インメモリ OLTP のサンプル データベース](sample-database-for-in-memory-oltp.md)
